import ts9 from 'typescript';

// src/comments.ts
function forEachToken(node, callback, sourceFile = node.getSourceFile()) {
  const queue = [];
  while (true) {
    if (ts9.isTokenKind(node.kind)) {
      callback(node);
    } else if (
      // eslint-disable-next-line deprecation/deprecation -- need for support of TS < 4.7
      node.kind !== ts9.SyntaxKind.JSDocComment
    ) {
      const children = node.getChildren(sourceFile);
      if (children.length === 1) {
        node = children[0];
        continue;
      }
      for (let i = children.length - 1; i >= 0; --i) {
        queue.push(children[i]);
      }
    }
    if (queue.length === 0) {
      break;
    }
    node = queue.pop();
  }
}

// src/comments.ts
function canHaveTrailingTrivia(token) {
  switch (token.kind) {
    case ts9.SyntaxKind.CloseBraceToken:
      return token.parent.kind !== ts9.SyntaxKind.JsxExpression || !isJsxElementOrFragment(token.parent.parent);
    case ts9.SyntaxKind.GreaterThanToken:
      switch (token.parent.kind) {
        case ts9.SyntaxKind.JsxOpeningElement:
          return token.end !== token.parent.end;
        case ts9.SyntaxKind.JsxOpeningFragment:
          return false;
        // would be inside the fragment
        case ts9.SyntaxKind.JsxSelfClosingElement:
          return token.end !== token.parent.end || // if end is not equal, this is part of the type arguments list
          !isJsxElementOrFragment(token.parent.parent);
        // there's only trailing trivia if it's the end of the top element
        case ts9.SyntaxKind.JsxClosingElement:
        case ts9.SyntaxKind.JsxClosingFragment:
          return !isJsxElementOrFragment(token.parent.parent.parent);
      }
  }
  return true;
}
function isJsxElementOrFragment(node) {
  return node.kind === ts9.SyntaxKind.JsxElement || node.kind === ts9.SyntaxKind.JsxFragment;
}
function forEachComment(node, callback, sourceFile = node.getSourceFile()) {
  const fullText = sourceFile.text;
  const notJsx = sourceFile.languageVariant !== ts9.LanguageVariant.JSX;
  return forEachToken(
    node,
    (token) => {
      if (token.pos === token.end) {
        return;
      }
      if (token.kind !== ts9.SyntaxKind.JsxText) {
        ts9.forEachLeadingCommentRange(
          fullText,
          // skip shebang at position 0
          token.pos === 0 ? (ts9.getShebang(fullText) ?? "").length : token.pos,
          commentCallback
        );
      }
      if (notJsx || canHaveTrailingTrivia(token)) {
        return ts9.forEachTrailingCommentRange(
          fullText,
          token.end,
          commentCallback
        );
      }
    },
    sourceFile
  );
  function commentCallback(pos, end, kind) {
    callback(fullText, { end, kind, pos });
  }
}
function isCompilerOptionEnabled(options, option) {
  switch (option) {
    case "stripInternal":
    case "declarationMap":
    case "emitDeclarationOnly":
      return options[option] === true && isCompilerOptionEnabled(options, "declaration");
    case "declaration":
      return options.declaration || isCompilerOptionEnabled(options, "composite");
    case "incremental":
      return options.incremental === void 0 ? isCompilerOptionEnabled(options, "composite") : options.incremental;
    case "skipDefaultLibCheck":
      return options.skipDefaultLibCheck || isCompilerOptionEnabled(options, "skipLibCheck");
    case "suppressImplicitAnyIndexErrors":
      return options.suppressImplicitAnyIndexErrors === true && isCompilerOptionEnabled(options, "noImplicitAny");
    case "allowSyntheticDefaultImports":
      return options.allowSyntheticDefaultImports !== void 0 ? options.allowSyntheticDefaultImports : isCompilerOptionEnabled(options, "esModuleInterop") || options.module === ts9.ModuleKind.System;
    case "noUncheckedIndexedAccess":
      return options.noUncheckedIndexedAccess === true && isCompilerOptionEnabled(options, "strictNullChecks");
    case "allowJs":
      return options.allowJs === void 0 ? isCompilerOptionEnabled(options, "checkJs") : options.allowJs;
    case "noImplicitAny":
    case "noImplicitThis":
    case "strictNullChecks":
    case "strictFunctionTypes":
    case "strictPropertyInitialization":
    case "alwaysStrict":
    case "strictBindCallApply":
      return isStrictCompilerOptionEnabled(
        options,
        option
      );
  }
  return options[option] === true;
}
function isStrictCompilerOptionEnabled(options, option) {
  return (options.strict ? options[option] !== false : options[option] === true) && (option !== "strictPropertyInitialization" || isStrictCompilerOptionEnabled(options, "strictNullChecks"));
}
function isFlagSet(allFlags, flag) {
  return (allFlags & flag) !== 0;
}
function isFlagSetOnObject(obj, flag) {
  return isFlagSet(obj.flags, flag);
}
function isModifierFlagSet(node, flag) {
  return isFlagSet(ts9.getCombinedModifierFlags(node), flag);
}
var isNodeFlagSet = isFlagSetOnObject;
function isObjectFlagSet(objectType, flag) {
  return isFlagSet(objectType.objectFlags, flag);
}
var isSymbolFlagSet = isFlagSetOnObject;
function isTransientSymbolLinksFlagSet(links, flag) {
  return isFlagSet(links.checkFlags, flag);
}
var isTypeFlagSet = isFlagSetOnObject;

// src/modifiers.ts
function includesModifier(modifiers, ...kinds) {
  if (modifiers === void 0) {
    return false;
  }
  for (const modifier of modifiers) {
    if (kinds.includes(modifier.kind)) {
      return true;
    }
  }
  return false;
}
function isAssignmentKind(kind) {
  return kind >= ts9.SyntaxKind.FirstAssignment && kind <= ts9.SyntaxKind.LastAssignment;
}
function isNumericPropertyName(name) {
  return String(+name) === name;
}
function charSize(ch) {
  return ch >= 65536 ? 2 : 1;
}
function isValidPropertyAccess(text, languageVersion = ts9.ScriptTarget.Latest) {
  if (text.length === 0) {
    return false;
  }
  let ch = text.codePointAt(0);
  if (!ts9.isIdentifierStart(ch, languageVersion)) {
    return false;
  }
  for (let i = charSize(ch); i < text.length; i += charSize(ch)) {
    ch = text.codePointAt(i);
    if (!ts9.isIdentifierPart(ch, languageVersion)) {
      return false;
    }
  }
  return true;
}

// src/nodes/access.ts
var AccessKind = /* @__PURE__ */ ((AccessKind2) => {
  AccessKind2[AccessKind2["None"] = 0] = "None";
  AccessKind2[AccessKind2["Read"] = 1] = "Read";
  AccessKind2[AccessKind2["Write"] = 2] = "Write";
  AccessKind2[AccessKind2["Delete"] = 4] = "Delete";
  AccessKind2[AccessKind2["ReadWrite"] = 3] = "ReadWrite";
  return AccessKind2;
})(AccessKind || {});
function getAccessKind(node) {
  const parent = node.parent;
  switch (parent.kind) {
    case ts9.SyntaxKind.DeleteExpression:
      return 4 /* Delete */;
    case ts9.SyntaxKind.PostfixUnaryExpression:
      return 3 /* ReadWrite */;
    case ts9.SyntaxKind.PrefixUnaryExpression:
      return parent.operator === ts9.SyntaxKind.PlusPlusToken || parent.operator === ts9.SyntaxKind.MinusMinusToken ? 3 /* ReadWrite */ : 1 /* Read */;
    case ts9.SyntaxKind.BinaryExpression:
      return parent.right === node ? 1 /* Read */ : !isAssignmentKind(parent.operatorToken.kind) ? 1 /* Read */ : parent.operatorToken.kind === ts9.SyntaxKind.EqualsToken ? 2 /* Write */ : 3 /* ReadWrite */;
    case ts9.SyntaxKind.ShorthandPropertyAssignment:
      return parent.objectAssignmentInitializer === node ? 1 /* Read */ : isInDestructuringAssignment(parent) ? 2 /* Write */ : 1 /* Read */;
    case ts9.SyntaxKind.PropertyAssignment:
      return parent.name === node ? 0 /* None */ : isInDestructuringAssignment(parent) ? 2 /* Write */ : 1 /* Read */;
    case ts9.SyntaxKind.ArrayLiteralExpression:
    case ts9.SyntaxKind.SpreadElement:
    case ts9.SyntaxKind.SpreadAssignment:
      return isInDestructuringAssignment(
        parent
      ) ? 2 /* Write */ : 1 /* Read */;
    case ts9.SyntaxKind.ParenthesizedExpression:
    case ts9.SyntaxKind.NonNullExpression:
    case ts9.SyntaxKind.TypeAssertionExpression:
    case ts9.SyntaxKind.AsExpression:
      return getAccessKind(parent);
    case ts9.SyntaxKind.ForOfStatement:
    case ts9.SyntaxKind.ForInStatement:
      return parent.initializer === node ? 2 /* Write */ : 1 /* Read */;
    case ts9.SyntaxKind.ExpressionWithTypeArguments:
      return parent.parent.token === ts9.SyntaxKind.ExtendsKeyword && parent.parent.parent.kind !== ts9.SyntaxKind.InterfaceDeclaration ? 1 /* Read */ : 0 /* None */;
    case ts9.SyntaxKind.ComputedPropertyName:
    case ts9.SyntaxKind.ExpressionStatement:
    case ts9.SyntaxKind.TypeOfExpression:
    case ts9.SyntaxKind.ElementAccessExpression:
    case ts9.SyntaxKind.ForStatement:
    case ts9.SyntaxKind.IfStatement:
    case ts9.SyntaxKind.DoStatement:
    case ts9.SyntaxKind.WhileStatement:
    case ts9.SyntaxKind.SwitchStatement:
    case ts9.SyntaxKind.WithStatement:
    case ts9.SyntaxKind.ThrowStatement:
    case ts9.SyntaxKind.CallExpression:
    case ts9.SyntaxKind.NewExpression:
    case ts9.SyntaxKind.TaggedTemplateExpression:
    case ts9.SyntaxKind.JsxExpression:
    case ts9.SyntaxKind.Decorator:
    case ts9.SyntaxKind.TemplateSpan:
    case ts9.SyntaxKind.JsxOpeningElement:
    case ts9.SyntaxKind.JsxSelfClosingElement:
    case ts9.SyntaxKind.JsxSpreadAttribute:
    case ts9.SyntaxKind.VoidExpression:
    case ts9.SyntaxKind.ReturnStatement:
    case ts9.SyntaxKind.AwaitExpression:
    case ts9.SyntaxKind.YieldExpression:
    case ts9.SyntaxKind.ConditionalExpression:
    case ts9.SyntaxKind.CaseClause:
    case ts9.SyntaxKind.JsxElement:
      return 1 /* Read */;
    case ts9.SyntaxKind.ArrowFunction:
      return parent.body === node ? 1 /* Read */ : 2 /* Write */;
    case ts9.SyntaxKind.PropertyDeclaration:
    case ts9.SyntaxKind.VariableDeclaration:
    case ts9.SyntaxKind.Parameter:
    case ts9.SyntaxKind.EnumMember:
    case ts9.SyntaxKind.BindingElement:
    case ts9.SyntaxKind.JsxAttribute:
      return parent.initializer === node ? 1 /* Read */ : 0 /* None */;
    case ts9.SyntaxKind.PropertyAccessExpression:
      return parent.expression === node ? 1 /* Read */ : 0 /* None */;
    case ts9.SyntaxKind.ExportAssignment:
      return parent.isExportEquals ? 1 /* Read */ : 0 /* None */;
  }
  return 0 /* None */;
}
function isInDestructuringAssignment(node) {
  switch (node.kind) {
    case ts9.SyntaxKind.ShorthandPropertyAssignment:
      if (node.objectAssignmentInitializer !== void 0) {
        return true;
      }
    // falls through
    case ts9.SyntaxKind.PropertyAssignment:
    case ts9.SyntaxKind.SpreadAssignment:
      node = node.parent;
      break;
    case ts9.SyntaxKind.SpreadElement:
      if (node.parent.kind !== ts9.SyntaxKind.ArrayLiteralExpression) {
        return false;
      }
      node = node.parent;
  }
  while (true) {
    switch (node.parent.kind) {
      case ts9.SyntaxKind.BinaryExpression:
        return node.parent.left === node && node.parent.operatorToken.kind === ts9.SyntaxKind.EqualsToken;
      case ts9.SyntaxKind.ForOfStatement:
        return node.parent.initializer === node;
      case ts9.SyntaxKind.ArrayLiteralExpression:
      case ts9.SyntaxKind.ObjectLiteralExpression:
        node = node.parent;
        break;
      case ts9.SyntaxKind.SpreadAssignment:
      case ts9.SyntaxKind.PropertyAssignment:
        node = node.parent.parent;
        break;
      case ts9.SyntaxKind.SpreadElement:
        if (node.parent.parent.kind !== ts9.SyntaxKind.ArrayLiteralExpression) {
          return false;
        }
        node = node.parent.parent;
        break;
      default:
        return false;
    }
  }
}
function isAbstractKeyword(node) {
  return node.kind === ts9.SyntaxKind.AbstractKeyword;
}
function isAccessorKeyword(node) {
  return node.kind === ts9.SyntaxKind.AccessorKeyword;
}
function isAnyKeyword(node) {
  return node.kind === ts9.SyntaxKind.AnyKeyword;
}
function isAssertKeyword(node) {
  return node.kind === ts9.SyntaxKind.AssertKeyword;
}
function isAssertsKeyword(node) {
  return node.kind === ts9.SyntaxKind.AssertsKeyword;
}
function isAsyncKeyword(node) {
  return node.kind === ts9.SyntaxKind.AsyncKeyword;
}
function isAwaitKeyword(node) {
  return node.kind === ts9.SyntaxKind.AwaitKeyword;
}
function isBigIntKeyword(node) {
  return node.kind === ts9.SyntaxKind.BigIntKeyword;
}
function isBooleanKeyword(node) {
  return nod